<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>RefBoard PixiJS Spike</title>
  <script src="https://cdn.jsdelivr.net/npm/pixi.js@8/dist/pixi.min.js"></script>
  <style>
    :root {
      --bg: #121212;
      --surface: #1a1a1a;
      --border: #333;
      --text: #f0f0f0;
      --text-muted: #666;
      --accent: #f5c518;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: var(--bg);
      color: var(--text);
      font-family: 'Inter', -apple-system, system-ui, sans-serif;
      overflow: hidden;
      height: 100vh;
    }
    .toolbar {
      position: fixed;
      top: 0; left: 0; right: 0;
      height: 48px;
      background: var(--surface);
      border-bottom: 1px solid var(--border);
      display: flex;
      align-items: center;
      padding: 0 16px;
      gap: 12px;
      z-index: 10;
    }
    .toolbar h1 {
      font-size: 14px;
      font-weight: 600;
      color: var(--accent);
    }
    .toolbar .sep {
      width: 1px;
      height: 24px;
      background: var(--border);
    }
    .toolbar .info {
      font-size: 12px;
      color: var(--text-muted);
      margin-left: auto;
    }
    .toolbar .zoom {
      font-size: 12px;
      color: var(--text-muted);
      font-variant-numeric: tabular-nums;
      min-width: 50px;
      text-align: center;
    }
    #canvas-container {
      position: fixed;
      top: 48px; left: 0; right: 0; bottom: 0;
    }
    .hint {
      position: fixed;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 8px 14px;
      font-size: 11px;
      color: var(--text-muted);
      display: flex;
      gap: 16px;
      z-index: 10;
    }
    .hint kbd {
      background: #222;
      border: 1px solid var(--border);
      padding: 2px 6px;
      border-radius: 3px;
      font-family: inherit;
      font-size: 10px;
    }
    .drop-overlay {
      position: fixed;
      inset: 48px 0 0 0;
      background: rgba(245, 197, 24, 0.08);
      border: 3px dashed var(--accent);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
      font-size: 20px;
      font-weight: 600;
      color: var(--accent);
    }
    .drop-overlay.active { display: flex; }
  </style>
</head>
<body>
  <div class="toolbar">
    <h1>PixiJS Spike</h1>
    <div class="sep"></div>
    <span class="zoom" id="zoomLabel">100%</span>
    <span class="info">Drop images onto canvas or use demo images</span>
  </div>
  <div id="canvas-container"></div>
  <div class="hint">
    <span><kbd>Scroll</kbd> Zoom</span>
    <span><kbd>Drag</kbd> Pan canvas</span>
    <span><kbd>Drag card</kbd> Move</span>
    <span><kbd>F</kbd> Fit view</span>
    <span><kbd>T</kbd> Tile</span>
    <span><kbd>Drop</kbd> Add images</span>
  </div>
  <div class="drop-overlay" id="dropOverlay">Drop images here</div>

  <script>
    (async () => {
      const container = document.getElementById('canvas-container');
      const zoomLabel = document.getElementById('zoomLabel');
      const dropOverlay = document.getElementById('dropOverlay');

      // Init PixiJS
      const app = new PIXI.Application();
      await app.init({
        resizeTo: container,
        background: 0x121212,
        antialias: true,
        resolution: window.devicePixelRatio || 1,
        autoDensity: true,
      });
      container.appendChild(app.canvas);

      // World container (pan & zoom target)
      const world = new PIXI.Container();
      app.stage.addChild(world);

      // Dot grid background
      const gridGfx = new PIXI.Graphics();
      world.addChild(gridGfx);

      function drawGrid() {
        gridGfx.clear();
        const spacing = 20;
        const majorEvery = 5;
        const bounds = getViewBounds();
        const startX = Math.floor(bounds.x / spacing) * spacing;
        const startY = Math.floor(bounds.y / spacing) * spacing;
        for (let x = startX; x < bounds.x + bounds.w; x += spacing) {
          for (let y = startY; y < bounds.y + bounds.h; y += spacing) {
            const isMajor = (x / spacing) % majorEvery === 0 && (y / spacing) % majorEvery === 0;
            gridGfx.circle(x, y, isMajor ? 1.5 : 0.8);
            gridGfx.fill({ color: 0xffffff, alpha: isMajor ? 0.15 : 0.04 });
          }
        }
      }

      function getViewBounds() {
        const w = app.screen.width / world.scale.x;
        const h = app.screen.height / world.scale.y;
        const x = -world.x / world.scale.x;
        const y = -world.y / world.scale.y;
        return { x, y, w, h };
      }

      // Card creation
      const cards = [];
      const CARD_W = 240;
      const CARD_RADIUS = 10;
      const CARD_BORDER = 0x333333;
      const CARD_BG = 0x222222;
      const CARD_SHADOW_ALPHA = 0.3;

      function createCard(texture, label, x, y) {
        const card = new PIXI.Container();
        card.x = x;
        card.y = y;
        card.eventMode = 'static';
        card.cursor = 'grab';

        // Aspect ratio
        const aspect = texture.height / texture.width;
        const imgW = CARD_W;
        const imgH = Math.round(imgW * Math.min(aspect, 1.2));
        const cardH = imgH + 44;

        // Shadow
        const shadow = new PIXI.Graphics();
        shadow.roundRect(4, 6, CARD_W, cardH, CARD_RADIUS);
        shadow.fill({ color: 0x000000, alpha: CARD_SHADOW_ALPHA });
        card.addChild(shadow);

        // Background
        const bg = new PIXI.Graphics();
        bg.roundRect(0, 0, CARD_W, cardH, CARD_RADIUS);
        bg.fill(CARD_BG);
        bg.stroke({ color: CARD_BORDER, width: 1 });
        card.addChild(bg);

        // Clipping mask for image
        const mask = new PIXI.Graphics();
        // Top rounded corners only - use full roundRect then cover bottom
        mask.roundRect(1, 1, CARD_W - 2, imgH, CARD_RADIUS);
        mask.fill(0xffffff);
        card.addChild(mask);

        // Image sprite
        const sprite = new PIXI.Sprite(texture);
        sprite.width = CARD_W - 2;
        sprite.height = imgH;
        sprite.x = 1;
        sprite.y = 1;
        sprite.mask = mask;
        card.addChild(sprite);

        // Label
        const text = new PIXI.Text({
          text: label,
          style: {
            fontFamily: 'Inter, -apple-system, system-ui, sans-serif',
            fontSize: 12,
            fontWeight: '500',
            fill: 0x999999,
            wordWrap: true,
            wordWrapWidth: CARD_W - 24,
          },
        });
        text.x = 12;
        text.y = imgH + 12;
        card.addChild(text);

        // Store dimensions for layout
        card._cardW = CARD_W;
        card._cardH = cardH;

        // Drag handling
        let dragging = false;
        let dragOffset = { x: 0, y: 0 };

        card.on('pointerdown', (e) => {
          dragging = true;
          card.cursor = 'grabbing';
          const pos = e.getLocalPosition(world);
          dragOffset.x = pos.x - card.x;
          dragOffset.y = pos.y - card.y;
          // Bring to front
          world.removeChild(card);
          world.addChild(card);
          e.stopPropagation();
        });

        card.on('globalpointermove', (e) => {
          if (!dragging) return;
          const pos = e.getLocalPosition(world);
          card.x = pos.x - dragOffset.x;
          card.y = pos.y - dragOffset.y;
        });

        card.on('pointerup', () => { dragging = false; card.cursor = 'grab'; });
        card.on('pointerupoutside', () => { dragging = false; card.cursor = 'grab'; });

        world.addChild(card);
        cards.push(card);
        return card;
      }

      // Pan & zoom
      let isPanning = false;
      let panStart = { x: 0, y: 0 };

      app.canvas.addEventListener('pointerdown', (e) => {
        isPanning = true;
        panStart.x = e.clientX - world.x;
        panStart.y = e.clientY - world.y;
        app.canvas.style.cursor = 'grabbing';
      });

      window.addEventListener('pointermove', (e) => {
        if (!isPanning) return;
        world.x = e.clientX - panStart.x;
        world.y = e.clientY - panStart.y;
        drawGrid();
      });

      window.addEventListener('pointerup', () => {
        isPanning = false;
        app.canvas.style.cursor = 'default';
      });

      app.canvas.addEventListener('wheel', (e) => {
        e.preventDefault();
        const rect = app.canvas.getBoundingClientRect();
        const mx = e.clientX - rect.left;
        const my = e.clientY - rect.top;
        const factor = e.deltaY > 0 ? 0.9 : 1.1;
        const oldScale = world.scale.x;
        const newScale = Math.max(0.05, Math.min(8, oldScale * factor));
        const ratio = newScale / oldScale;
        world.x = mx - (mx - world.x) * ratio;
        world.y = my - (my - world.y) * ratio;
        world.scale.set(newScale);
        zoomLabel.textContent = Math.round(newScale * 100) + '%';
        drawGrid();
      }, { passive: false });

      // Fit view
      function fitView() {
        if (!cards.length) return;
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        for (const c of cards) {
          minX = Math.min(minX, c.x);
          minY = Math.min(minY, c.y);
          maxX = Math.max(maxX, c.x + c._cardW);
          maxY = Math.max(maxY, c.y + c._cardH);
        }
        const cw = maxX - minX + 80;
        const ch = maxY - minY + 80;
        const s = Math.min(app.screen.width / cw, app.screen.height / ch, 1) * 0.85;
        world.scale.set(s);
        world.x = (app.screen.width - cw * s) / 2 - minX * s;
        world.y = (app.screen.height - ch * s) / 2 - minY * s;
        zoomLabel.textContent = Math.round(s * 100) + '%';
        drawGrid();
      }

      // Auto tile
      function autoTile() {
        if (!cards.length) return;
        const cols = Math.ceil(Math.sqrt(cards.length * 1.2));
        const gapX = 40, gapY = 40;
        cards.forEach((c, i) => {
          c.x = 40 + (i % cols) * (CARD_W + gapX);
          c.y = 40 + Math.floor(i / cols) * (c._cardH + gapY);
        });
        fitView();
      }

      // Keyboard
      document.addEventListener('keydown', (e) => {
        if (e.target.tagName === 'INPUT') return;
        if (e.key === 'f') fitView();
        if (e.key === 't') autoTile();
      });

      // Drag & drop images from filesystem
      document.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropOverlay.classList.add('active');
      });
      document.addEventListener('dragleave', (e) => {
        if (e.target === dropOverlay) dropOverlay.classList.remove('active');
      });
      document.addEventListener('drop', (e) => {
        e.preventDefault();
        dropOverlay.classList.remove('active');
        for (const file of e.dataTransfer.files) {
          if (!file.type.startsWith('image/')) continue;
          const reader = new FileReader();
          reader.onload = async (ev) => {
            const texture = await PIXI.Assets.load(ev.target.result);
            const cx = (-world.x + app.screen.width / 2) / world.scale.x;
            const cy = (-world.y + app.screen.height / 2) / world.scale.y;
            createCard(texture, file.name.replace(/\.[^.]+$/, ''), cx - CARD_W / 2 + cards.length * 20, cy - 150 + cards.length * 20);
          };
          reader.readAsDataURL(file);
        }
      });

      // Generate demo placeholder images via canvas
      function makeDemoTexture(w, h, hue, label) {
        const cvs = document.createElement('canvas');
        cvs.width = w;
        cvs.height = h;
        const ctx = cvs.getContext('2d');
        // Gradient background
        const grad = ctx.createLinearGradient(0, 0, w, h);
        grad.addColorStop(0, `hsl(${hue}, 60%, 25%)`);
        grad.addColorStop(1, `hsl(${hue + 40}, 50%, 15%)`);
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, w, h);
        // Geometric shapes
        ctx.strokeStyle = `hsla(${hue}, 70%, 50%, 0.3)`;
        ctx.lineWidth = 2;
        for (let i = 0; i < 5; i++) {
          const x = Math.random() * w;
          const y = Math.random() * h;
          const r = 20 + Math.random() * 60;
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.stroke();
        }
        // Label
        ctx.fillStyle = `hsla(${hue}, 60%, 70%, 0.6)`;
        ctx.font = 'bold 16px Inter, system-ui, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText(label, w / 2, h / 2 + 6);
        return PIXI.Texture.from(cvs);
      }

      // Create demo cards
      const demos = [
        { w: 400, h: 500, hue: 40,  label: 'Art Deco' },
        { w: 600, h: 400, hue: 200, label: 'Blueprint' },
        { w: 400, h: 600, hue: 340, label: 'Typography' },
        { w: 500, h: 500, hue: 120, label: 'Texture' },
        { w: 400, h: 300, hue: 270, label: 'Abstract' },
        { w: 350, h: 500, hue: 20,  label: 'Sculpture' },
      ];

      demos.forEach((d, i) => {
        const tex = makeDemoTexture(d.w, d.h, d.hue, d.label);
        const cols = 3;
        const x = 60 + (i % cols) * (CARD_W + 40);
        const y = 60 + Math.floor(i / cols) * 360;
        createCard(tex, d.label, x, y);
      });

      // Initial fit
      fitView();
      drawGrid();

      // Redraw grid on resize
      window.addEventListener('resize', () => drawGrid());
    })();
  </script>
</body>
</html>
